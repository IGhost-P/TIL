# TIL ê°„ë‹¨íšŒê³ 

# Today I Learned

- [x] í† ìµ 21, 22
- [x] VanilaJS (9:30~10:40 , 10:45~12:05)
- [x] ì •ë³´ì²˜ë¦¬ê¸°ì‚¬ (1:10 ~ 4:13)
- [x] ì•Œê³ ë¦¬ì¦˜ (4:20 ~ 6:00, 6:40~ 9: 20)
- [x] í† ìµ ì‹œì œ (00:30~01:6)

---

# ğŸ“¹ ë™ì˜ìƒ

[![section13](../../img/ì¸ë„¤ì¼/TIL.png)](https://youtu.be/2AIixRLDvaU)

# Consuming Promises with Async/Await

> ë¹„ë™ê¸° ì²˜ë¦¬ í•¨ìˆ˜ë¥¼ ë§Œë“¤ì–´ ë³€ìˆ˜ì— ë‹´ì„ ìˆ˜ìˆë‹¤

```jsx
const foo = async function () {
  await ì½œë°±í•¨ìˆ˜;
};
```

- í•´ë‹¹ í•¨ìˆ˜ëŠ” ë°±ê·¸ë¼ìš´ë“œì—ì„œ ì²˜ë¦¬ë˜ê¸° ë•Œë¬¸ì— ì•ˆì— ë‚´ìš©ì€ ë™ê¸°ì ì´ë‚˜ í˜¸ì¶œìŠ¤íƒì—ëŠ” ì˜í–¥ì´ ì—†ë‹¤

# Error Handling With try...catch

> .catchê°€ ë˜ì§€ ì•Šê¸° ë–„ë¬¸ì— try, catchë¬¸ìœ¼ë¡œ ì—ëŸ¬ ì²˜ë¦¬ë¥¼ í•´ì•¼í•œë‹¤

- ì—ëŸ¬ê°€ ì—†ë‹¤ë©´, ì†Œë¹„ í”„ë¡œë¯¸ìŠ¤ì—ì„œ ì—ëŸ¬ê°€ ìˆì„ê²½ìš°ë¥¼ ëŒ€ë¹„í•´ throw err;ë¥¼ í•´ì¤˜ì•¼í•œë‹¤

# Running Promises in Parallel

> ë³‘í–‰ ì²˜ë¦¬ë¥¼ í•˜ë ¤ë©´ Promis.allì´ ìˆë‹¤ ë‚˜ë¨¸ì§€ëŠ” race, allSettled, anyë“±ì´ ìˆë‹¤

# Coding Challenge #3

```jsx
// Coding Challenge #3

/* 
PART 1
Write an async function 'loadNPause' that recreates Coding Challenge #2, this time using async/await (only the part where the promise is consumed). Compare the two versions, think about the big differences, and see which one you like more.
Don't forget to test the error handler, and to set the network speed to 'Fast 3G' in the dev tools Network tab.

PART 2
1. Create an async function 'loadAll' that receives an array of image paths 'imgArr';
2. Use .map to loop over the array, to load all the images with the 'createImage' function (call the resulting array 'imgs')
3. Check out the 'imgs' array in the console! Is it like you expected?
4. Use a promise combinator function to actually get the images from the array ğŸ˜‰
5. Add the 'paralell' class to all the images (it has some CSS styles).

TEST DATA: ['img/img-1.jpg', 'img/img-2.jpg', 'img/img-3.jpg']. To test, turn off the 'loadNPause' function.

GOOD LUCK ğŸ˜€
*/
const wait = function (seconds) {
  return new Promise(function (resolve) {
    setTimeout(resolve, seconds * 1000);
  });
};

const createImage = function (imgPath) {
  return new Promise(function (resolve, reject) {
    const img = document.createElement("img");
    img.src = imgPath;

    img.addEventListener("load", function () {
      imgContainer.append(img);
      resolve(img);
    });

    img.addEventListener("error", function () {
      reject(new Error("Image not found"));
    });
  });
};

const imgContainer = document.querySelector(".images");

// Part 1
const loadPause = async function () {
  try {
    let img = await createImage("img/img-1.jpg");
    if (!img) throw new Error("Image 1 not Found");
    console.log("Image 1 loaded");
    await wait(2);
    img.style.display = "none";

    img = await createImage("img/img-2.jpg");
    if (!img) throw new Error("Image 2 not Found");
    console.log("Image 2 loaded");
    await wait(2);
    img.style.display = "none";

    img = await createImage("img/img-3.jpg");
    if (!img) throw new Error("Image 3 not Found");
    console.log("Image 2 loaded");
    await wait(2);
    img.style.display = "none";
  } catch (err) {
    console.error(err);
  }
};

// Part 2
const imgArr = ["img/img-1.jpg", "img/img-2.jpg", "img/img-3.jpg"];

const loadAll = async function (imgArr) {
  try {
    const imgs = imgArr.map(async (el) => {
      return await createImage(el);
    });
    const imgsEl = await Promise.all(imgs);
    // console.log(imgsEl);

    imgsEl.forEach((imgEl) => {
      imgEl.classList.add("parallel"); // imges í´ë˜ìŠ¤ì— ì´ë¯¸ ë“¤ì–´ê°€ ìˆê³  ê±°ê¸°ì— parallelë¥¼ ì¶”ê°€í•¨
    });
  } catch (err) {
    console.error(err);
  }
};

// ---------- ì„¼ì„¸ë‹µ  ----------
const wait = function (seconds) {
  return new Promise(function (resolve) {
    setTimeout(resolve, seconds * 1000);
  });
};

const imgContainer = document.querySelector(".images");

const createImage = function (imgPath) {
  return new Promise(function (resolve, reject) {
    const img = document.createElement("img");
    img.src = imgPath;

    img.addEventListener("load", function () {
      imgContainer.append(img);
      resolve(img);
    });

    img.addEventListener("error", function () {
      reject(new Error("Image not found"));
    });
  });
};

let currentImg;

// createImage('img/img-1.jpg')
//   .then(img => {
//     currentImg = img;
//     console.log('Image 1 loaded');
//     return wait(2);
//   })
//   .then(() => {
//     currentImg.style.display = 'none';
//     return createImage('img/img-2.jpg');
//   })
//   .then(img => {
//     currentImg = img;
//     console.log('Image 2 loaded');
//     return wait(2);
//   })
//   .then(() => {
//     currentImg.style.display = 'none';
//   })
//   .catch(err => console.error(err));

// PART 1
const loadNPause = async function () {
  try {
    // Load image 1
    let img = await createImage("img/img-1.jpg");
    console.log("Image 1 loaded");
    await wait(2);
    img.style.display = "none";

    // Load image 1
    img = await createImage("img/img-2.jpg");
    console.log("Image 2 loaded");
    await wait(2);
    img.style.display = "none";
  } catch (err) {
    console.error(err);
  }
};
// loadNPause();

// PART 2
const loadAll = async function (imgArr) {
  try {
    const imgs = imgArr.map(async (img) => await createImage(img));
    const imgsEl = await Promise.all(imgs);
    console.log(imgsEl);
    imgsEl.forEach((img) => img.classList.add("parallel"));
  } catch (err) {
    console.error(err);
  }
};
loadAll(["img/img-1.jpg", "img/img-2.jpg", "img/img-3.jpg"]);
```

# ì•Œê³ ë¦¬ì¦˜

## 5719 : ê±°ì˜ ìµœë‹¨ê²½ë¡œ

# ë¬¸ì œí’€ì´

- ë‹¤ìµìŠ¤íŠ¸ë¼ë¡œ ìµœë‹¨ ê²½ë¡œë¥¼ ì°¾ëŠ”ë‹¤
- BFSë¡œ ì—­ì¶”ì í•´ ìµœë‹¨ ê²½ë¡œë¥¼ ì°¾ëŠ”ë‹¤
- ë‹¤ìµìŠ¤íŠ¸ë¼ë¥¼ ë‹¤ì‹œ ëŒë¦°ë‹¤
- â‡’ ë‚˜ì¤‘ì—ëŠ” ë‹¤ìµìŠ¤íŠ¸ë¼ë¥¼ ëŒë¦´ë•Œ í•´ë‹¹ ê²½ë¡œë¥¼ ë”°ë¡œ ì €ì¥í•´ ì°¾ì•„ê°€ëŠ” ë°©ì‹ìœ¼ë¡œ í’€ì–´ë³´ê³  ì‹¶ë‹¤

```jsx
// ê±°ì˜ ìµœë‹¨ ê²½ë¡œ
/*
ìµœë‹¨ ê²½ë¡œì— í¬í•¨ë˜ì–´ ìˆì§€ ì•Šì€ ê²½ë¡œë¡œ ìµœë‹¨ ê²½ë¡œ
=> ìµœë‹¨ ê²½ë¡œê°€ ëœ ì• ë“¤ì„ ë¹¼ê³  ë‹¤ì‹œ ëŒë¦¬ë©´ ë ê²ƒ ê°™ìŠµë‹ˆë‹¤
1ë²ˆì§¸ì¤„ = [ì¥ì†Œìˆ˜, ë„ë¡œìˆ˜]
2ë²ˆì§¸ ì¤„ = [ì‹œì‘ì , ì¶œë°œì ]
3ë²ˆì§¸ ì¤„ë¶€í„°ëŠ” ê³„ì†
... ë‹¤ìŒ .lengthê°€ 2ë²ˆì§¸ ì´ë©´ ë‹¤ì‹œ ì‹œì‘
*/
// ê·¸ë˜í”„

// Mapì„ ì´ìš©í•´ì„œ ë„£ìŒ
function setGraph(arr) {
  const g = new Map();
  const reverseG = new Map();

  arr.forEach((a) => {
    const [x, y, dist] = a.split(" ").map((b) => +b);

    // xë¥¼ ì¡°íšŒí–ˆì„ëŒ€ í‚¤ê°’ì— ì—†ë‹¤ë©´?
    if (!g.get(x)) {
      g.set(x, []); // ë„£ì–´ì¤Œ
    }

    // yë¥¼ ì¡°íšŒí–ˆëŠ”ë° í‚¤ê°’ì— ì—†ë‹¤ë©´?
    if (!reverseG.get(y)) {
      reverseG.set(y, []);
    }

    // ì¡°íšŒí•œ í‚¤ê°’ì— [ê°€ì¤‘ì¹˜ , to]ë¥¼ ì„¤ì •
    g.get(x).push([dist, y]);
    reverseG.get(y).push([dist, x]);
  });

  return { g, reverseG };
}
// ------ ì‹œì‘ ------

input = require("fs").readFileSync("ì˜ˆì œ.txt").toString().trim().split("\n");
len = input.length;

function solutuion(input) {
  // ìŠ¬ë¼ì´ì‹±ì„ í• ê²ƒì´ê¸° ë•Œë¬¸ì— inputì´ ë”ì´ìƒ ì—†ë‹¤ë©´ í•„ìš”ì—†ë‹¤
  while (input.length > 0) {
    // ì²«ë²ˆì§¸ì¤„
    [node, road] = input.shift().split(" ").map(Number);
    // console.log(node, road); // ì²«ë²ˆì§¸ì¤„ í™•ì¸ìš©

    // Guard clause = ì¢…ë£Œ ì¡°ê±´
    if (node == 0 && road == 0) return;

    // ë‘ë²ˆì§¸ì¤„
    [start, end] = input.shift().split(" ").map(Number);
    // console.log(start, end); //ë‘ë²ˆì§¸ ì¤„ í™•ì¸ìš©

    // testCaseë³„ ë‚˜ëˆ„ê¸°
    newinput = input.splice(0, road);

    // testCaseë³„ ìˆœíšŒ

    // ë„¤íŠ¸ì›Œí¬ ë§Œë“¤ê¸°
    const { g, reverseG } = setGraph(newinput);
    network = g;
    reverseNetwork = reverseG;

    // ë„ë¡œ ë§Œë“¤ê¸° : ìˆ«ìê°€ í‚¤ì´ê³ , ì¸ë±ìŠ¤ë¡œ ë“¤ì–´ê°ˆê²ƒì´ê¸° ë•Œë¬¸ì—, +1ì„ í•´ì¤Œ
    let distances = new Array(node + 1).fill(Infinity);
    let dropped = Array.from({ length: node + 1 }, () =>
      new Array(node + 1).fill(false)
    );

    dijkstra(network, start, distances, dropped);
    bfs(start, end, distances, dropped, reverseNetwork);

    // ë‹¤ì‹œ ìµœë‹¨ê±°ë¦¬ && ì´ì „ ìµœë‹¨ê±°ë¦¬ì— ì˜í•´ ë¸”ë¡ëœ ìœ„ì¹˜ = ìµœë‹¨ê±°ë¦¬ê°€ ì•„ë‹Œ ìµœë‹¨ê±°ë¦¬
    distances = new Array(node + 1).fill(Infinity);
    dijkstra(network, start, distances, dropped);

    const result = distances[end] === Infinity ? -1 : distances[end];
    console.log(result);
  }
}

function dijkstra(network, start, distances, dropped) {
  heapq = []; // heapqë¥¼ ì‚¬ìš©í•˜ì§€ ì•Šê³  ë§ˆì§€ë§‰ì— ë„£ì–´ì¤„ë•Œ ì •ë ¬ì„ í•´ì£¼ì
  distances[start] = 0;
  heapq.push([distances[start], start]);
  while (heapq.length > 0) {
    [dist, currentNode] = heapq.shift();

    if (distances[currentNode] < dist) {
      continue;
    }

    // for ([adjacent, d] of network[currentNode]) {
    //   distance = dist + d;
    //   if (distance < distances[adjacent] && !dropped[currentNode][adjacent]) {
    //     distances[adjacent] = distance;
    //     heapq.push([distance, adjacent]);
    //     heapq.sort((a, b) => a[0] - b[0]);
    //   }
    // }
    if (!!network.get(currentNode)) {
      // currentNideì˜ í‚¤ì— ìˆëŠ” valueë“¤
      // [undefind, null, 0ì¼ ê²½ìš° false]
      network.get(currentNode).forEach((el) => {
        const cost = dist + el[0];
        if (distances[el[1]] > cost && !dropped[currentNode][el[1]]) {
          distances[el[1]] = cost;
          heapq.push([cost, el[1]]);
          heapq.sort((a, b) => a[0] - b[0]);
        }
      });
    }
  }
  return distances;
}

function bfs(start, end, distances, dropped, reverseNetwork) {
  const q = [end];
  const visited = [];
  while (q.length > 0) {
    currentNode = q.shift();
    if (currentNode == start) continue;
    // for ([prev, d] of reverseNetwork[currentNode]) {
    //   if (distances[currentNode] == distances[prev] + d) {
    //     dropped[prev][currentNode] = true;
    //     q.push(prev);
    //   }
    // }
    if (!!reverseNetwork.get(currentNode) && !visited.includes(currentNode)) {
      // ë°©ë¬¸í•˜ì§€ ì•Šì•˜ë‹¤ë©´
      visited.push(currentNode);
      reverseNetwork.get(currentNode).forEach((a) => {
        const [dist, prev] = a;
        const cost = distances[prev] + dist; // ë‹¤ìŒë²ˆìœ¼ë¡œê°€ëŠ” ê°’ì´ ìµœë‹¨ê±°ë¦¬ ê°’ê³¼ ê°™ë‹¤ë©´ (ì¦‰ a(2)->(3)->c:5 , b(2)->-(4)->c:6 ë¼ í• ëŒ€, c->(3)->a(2) : 5ê°€ ë˜ëŠ”ê²½ìš°ë¥¼ ì°¾ìœ¼ë©´ ë˜ëŠ”ê²ƒ )
        if (distances[currentNode] === cost) {
          dropped[prev][currentNode] = true; // í•´ë‹¹í•˜ëŠ” ìœ„ì¹˜ëŠ” trueë¡œ
          q.push(prev); // qëŠ” ê³„ì†ëœë‹¤..
        }
      });
    }
  }
}

solutuion(input);
```

---

# ë§ˆì§€ë§‰ìœ¼ë¡œ
