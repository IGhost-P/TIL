# TIL ê°„ë‹¨íšŒê³ 

> JSë¡œ ìë£Œêµ¬ì¡°ë¥¼ ì´ìš©í•˜ëŠ”ê²Œ ìƒê°ë³´ë‹¤ í˜ë“¤ì—ˆë‹¤, ìë£Œêµ¬ì¡° ìª½ì„ ì§ì ‘ êµ¬í˜„í•˜ê³  ì•”ê¸°ë¥¼ í•´ì•¼ê² ë‹¤

# Today I Learned

- [x] íƒ€ì„ë¡œê·¸ ì‘ì„±
- [x] í† ìµ
- [x] VanilaJS (08:30~12:53)
- [x] ì•Œê³ ë¦¬ì¦˜ (7:00~12:18)

---

# ğŸ“¹ ë™ì˜ìƒ

[![section13](../../img/ì¸ë„¤ì¼/TIL.png)](https://youtu.be/mGG0ufVQ8Gc)

# ì•Œì•„ë‘ë©´ ì¢‹ì€ê²ƒ : JS

- this í•¸ë“¤ë§ì´ ì¤‘ìš”í•˜ë‹¤, íŠ¹íˆ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆì— ì½œë°±í•¨ìˆ˜ë¡œ ë°”ì¸ë”©ëœ í•¨ìˆ˜ëŠ” í•´ë‹¹ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆë¥¼ ë“±ë¡í•œ ê°ì²´ë¥¼ ê°€ë¥´í‚¨ë‹¤, ê·¸ë ‡ê¸° ë•Œë¬¸ì— í´ë˜ìŠ¤ì˜ í”„ë¡œí¼í‹°ë¥¼ ì‚¬ìš©í•˜ë ¤ê³  í•˜ë©´ this ë°”ì¸ë”©ì„ í•´ì¤˜ì•¼í•œë‹¤ (ë˜ëŠ” ìŠ¤ì½”í”„ë¥¼ ì´ìš©í•˜ê²Œ , í™”ì‚´í‘œí•¨ìˆ˜ë¥¼ ì´ìš©í•˜ì)
- idë¥¼ íƒ€ì„ìŠ¤íƒ¬í”„ë¡œ í•˜ëŠ”ê²ƒì€ ì¢‹ì§€ ì•Šë‹¤, ë™ì‹œì— ì‚¬ìš©ìê°€ ì‚¬ìš©í•˜ê²Œ ë˜ë©´ idê°€ ì¤‘ë³µ ë ìˆ˜ ìˆê¸° ë•Œë¬¸ì´ë‹¤
- ê¸°ëŠ¥ì€ ë”°ë¡œ êµ¬ë¶„í•´ì„œ ë§Œë“¤ê³ , ê¸°ëŠ¥ êµ¬í˜„ì„ ìœ„í•˜ í—¬í¼ í•¨ìˆ˜ë¥¼ ë§Œë“¤ì–´ ì‚¬ìš©í•˜ì
- datasetì— í•´ë‹¹ ì—˜ë¦¬ë¨¼íŠ¸ë¥¼ ê°€ë¥´í‚¤ëŠ” ê³ ìœ í•œ ê°’ì„ ë„£ëŠ”ë‹¤ë©´, ë‚˜ì¤‘ì— í•´ë‹¹ ë°ì´í„°ë¥¼ ì°¾ì„ë•Œ í¸í•˜ë‹¤
- ë¡œì»¬ìŠ¤í† ë¦¬ì§€ë¥¼ ì´ìš©í• ë•ŒëŠ” í•­ìƒ ë¹„ë™ê¸° ì²˜ë¦¬ë¥¼ ìƒê°í•˜ì, ë¡œì»¬ìŠ¤í† ë¦¬ì§€ì— ì €ì¥ëœ ë°ì´í„°ê°€, ì•ì„  ë°ì´í„°ê°€ í•„ìš”í•œ ê²½ìš°ê°€ ë§ê¸° ë•Œë¬¸

# ì•Œê³ ë¦¬ì¦˜

## 1927 : ìµœì†Œ í™

# 1927 : ìµœì†Œ í™

# ìµœì†Œ í™

## ë¬¸ì œ

ë„ë¦¬ ì˜ ì•Œë ¤ì§„ ìë£Œêµ¬ì¡° ì¤‘ ìµœì†Œ í™ì´ ìˆë‹¤. ìµœì†Œ í™ì„ ì´ìš©í•˜ì—¬ ë‹¤ìŒê³¼ ê°™ì€ ì—°ì‚°ì„ ì§€ì›í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì‹œì˜¤.

1. ë°°ì—´ì— ìì—°ìˆ˜ xë¥¼ ë„£ëŠ”ë‹¤.
2. ë°°ì—´ì—ì„œ ê°€ì¥ ì‘ì€ ê°’ì„ ì¶œë ¥í•˜ê³ , ê·¸ ê°’ì„ ë°°ì—´ì—ì„œ ì œê±°í•œë‹¤.

í”„ë¡œê·¸ë¨ì€ ì²˜ìŒì— ë¹„ì–´ìˆëŠ” ë°°ì—´ì—ì„œ ì‹œì‘í•˜ê²Œ ëœë‹¤.

## ì…ë ¥

ì²«ì§¸ ì¤„ì— ì—°ì‚°ì˜ ê°œìˆ˜ N(1 â‰¤ N â‰¤ 100,000)ì´ ì£¼ì–´ì§„ë‹¤. ë‹¤ìŒ Nê°œì˜ ì¤„ì—ëŠ” ì—°ì‚°ì— ëŒ€í•œ ì •ë³´ë¥¼ ë‚˜íƒ€ë‚´ëŠ” ì •ìˆ˜ xê°€ ì£¼ì–´ì§„ë‹¤. ë§Œì•½ xê°€ ìì—°ìˆ˜ë¼ë©´ ë°°ì—´ì— xë¼ëŠ” ê°’ì„ ë„£ëŠ”(ì¶”ê°€í•˜ëŠ”) ì—°ì‚°ì´ê³ , xê°€ 0ì´ë¼ë©´ ë°°ì—´ì—ì„œ ê°€ì¥ ì‘ì€ ê°’ì„ ì¶œë ¥í•˜ê³  ê·¸ ê°’ì„ ë°°ì—´ì—ì„œ ì œê±°í•˜ëŠ” ê²½ìš°ì´ë‹¤. xëŠ” 231ë³´ë‹¤ ì‘ì€ ìì—°ìˆ˜ ë˜ëŠ” 0ì´ê³ , ìŒì˜ ì •ìˆ˜ëŠ” ì…ë ¥ìœ¼ë¡œ ì£¼ì–´ì§€ì§€ ì•ŠëŠ”ë‹¤.

## ì¶œë ¥

ì…ë ¥ì—ì„œ 0ì´ ì£¼ì–´ì§„ íšŸìˆ˜ë§Œí¼ ë‹µì„ ì¶œë ¥í•œë‹¤. ë§Œì•½ ë°°ì—´ì´ ë¹„ì–´ ìˆëŠ” ê²½ìš°ì¸ë° ê°€ì¥ ì‘ì€ ê°’ì„ ì¶œë ¥í•˜ë¼ê³  í•œ ê²½ìš°ì—ëŠ” 0ì„ ì¶œë ¥í•˜ë©´ ëœë‹¤.

## ì˜ˆì œ ì…ë ¥ 1

```
9
0
12345678
1
2
0
0
0
0
32

```

## ì˜ˆì œ ì¶œë ¥ 1

```
0
1
2
12345678
0
```

---

# ë¬¸ì œí’€ì´

- ìµœì†Œí™ì„ ë§Œë“ ë‹¤
- ë„ë¦¬ì‰¬ ì—°ì‚°ìë¥¼ í†µí•´ undefind ê°’ì„ ê³¨ë¼ë‚¸ë‹¤

```jsx
class MinHeap {
  constructor() {
    this.heap = [null];
  }
  swap(a, b) {
    [this.heap[a], this.heap[b]] = [this.heap[b], this.heap[a]];
  }

  heappush(value) {
    this.heap.push(value);
    let curIdx = this.heap.length - 1; // í˜„ì¬ ë“¤ì–´ê°„ ê°’ì˜ idxê°’
    let parIdx = (curIdx / 2) >> 0; // ì˜¤ë¥¸ìª½ìœ¼ë¡œ 0ë²ˆ ì´ë™í•˜ë©´ ì†Œìˆ«ì ì„ ì—†ì• ì¤€ë‹¤

    while (curIdx > 1 && this.heap[parIdx] > this.heap[curIdx]) {
      this.swap(parIdx, curIdx);
      // ë°”ê¿¨ìœ¼ë‹ˆê¹ idxë„ ë°”ê¿ˆ
      curIdx = parIdx;
      parIdx = (curIdx / 2) >> 0;
    }
  }

  heappop() {
    const min = this.heap[1];
    if (this.heap.length <= 2) this.heap = [null];
    else this.heap[1] = this.heap.pop();

    let curIdx = 1;
    let leftIdx = curIdx * 2; // ì™¼ìª½ ìì‹ì˜ index
    let rightIdx = curIdx * 2 + 1;

    // ì™¼ìª½ ìì‹ì´ ì—†ìŒ => ì˜¤ë¥¸ìª½ ìì‹ì´ ì—†ìŒ => ê±±ì •ì—†ì´ ë½‘ì
    if (!this.heap[leftIdx]) return min;
    // ì˜¤ë¥¸ìª½ ìì‹ì´ ì—†ìŒ => ì™¼ìª½ ìì‹ë§Œ ì‹ ê²½ì“°ë©´ë¨
    if (!this.heap[rightIdx]) {
      // ë¹ ì§ˆ ê°’ì´ ë” í¬ë©´ ë°”ê¿”ì£¼ì
      if (this.heap[leftIdx] < this.heap[curIdx]) {
        this.swap(leftIdx, curIdx);
      }
      return min;
    }
    while (
      this.heap[leftIdx] < this.heap[curIdx] ||
      this.heap[rightIdx] < this.heap[curIdx]
    ) {
      // ë” ì‘ì€ ê°’ì´ popí›„ì˜ idxë¥¼ ê°€ì ¸ì•¼í•¨
      const minIdx =
        this.heap[leftIdx] > this.heap[rightIdx] ? rightIdx : leftIdx;
      this.swap(minIdx, curIdx); // ë” ì‘ì€ ê°’ê³¼ ì§€ê¸ˆ ë¹„êµì¤‘ì´ ê°’ì„ ë°”ê¿”ì¤Œ
      // idxë„ ë°”ê¿”ì¤Œ
      curIdx = minIdx;
      leftIdx = curIdx * 2;
      rightIdx = curIdx * 2 + 1;

      // .. ì´ë ‡ê²Œ ë°˜ë³µí•˜ë‹¤ ë³´ë©°ëŠ left < cur < rightê°€ ë ë–„ê¹Œì§€ ë°˜ë³µí•œë‹¤
    }
    return min;
  }
}

let answer = [];
const solution = () => {
  [testCase, ...arr] = require("fs")
    .readFileSync("/dev/stdin")
    .toString()
    .trim()
    .split("\n")
    .map(Number);

  const heapq = new MinHeap();
  for (let i = 0; i < testCase; i++) {
    el = arr[i];
    if (el == "0") {
      result = heapq.heappop() ?? 0;
      answer.push(result);
    } else {
      heapq.heappush(el);
    }
  }
};
solution();
console.log(answer.join("\n"));
```

## 1715 : ì¹´ë“œ ì •ë ¬í•˜ê¸°

```jsx
class MinHeap {
  constructor() {
    this.heap = [null];
  }

  size() {
    return this.heap.length - 1;
  }

  getMin() {
    return this.heap[1] ? this.heap[1] : null;
  }

  swap(a, b) {
    [this.heap[a], this.heap[b]] = [this.heap[b], this.heap[a]];
  }

  heappush(value) {
    this.heap.push(value);
    let curIdx = this.heap.length - 1;
    let parIdx = (curIdx / 2) >> 0;

    while (curIdx > 1 && this.heap[parIdx] > this.heap[curIdx]) {
      this.swap(parIdx, curIdx);
      curIdx = parIdx;
      parIdx = (curIdx / 2) >> 0;
    }
  }

  heappop() {
    const min = this.heap[1];
    if (this.heap.length <= 2) this.heap = [null];
    else this.heap[1] = this.heap.pop();

    let curIdx = 1;
    let leftIdx = curIdx * 2;
    let rightIdx = curIdx * 2 + 1;

    if (!this.heap[leftIdx]) return min;
    if (!this.heap[rightIdx]) {
      if (this.heap[leftIdx] < this.heap[curIdx]) {
        this.swap(leftIdx, curIdx);
      }
      return min;
    }

    while (
      this.heap[leftIdx] < this.heap[curIdx] ||
      this.heap[rightIdx] < this.heap[curIdx]
    ) {
      const minIdx =
        this.heap[leftIdx] > this.heap[rightIdx] ? rightIdx : leftIdx;
      this.swap(minIdx, curIdx);
      curIdx = minIdx;
      leftIdx = curIdx * 2;
      rightIdx = curIdx * 2 + 1;
    }

    return min;
  }
}
let answer = 0;
const heapq = new MinHeap();

const solution = () => {
  [testCase, ...arr] = require("fs")
    .readFileSync("/dev/stdin")
    .toString()
    .trim()
    .split("\n")
    .map(Number);
  for (let i = 0; i < testCase; i++) {
    heapq.heappush(arr[i]);
  }
  while (heapq.size() > 1) {
    fri = heapq.heappop();
    sec = heapq.heappop();
    pushNum = fri + sec;
    answer += pushNum;
    heapq.heappush(pushNum);
    // console.log(fri, sec, heapq);
  }
};
solution();
console.log(answer);
```

## 1766 : ë¬¸ì œì§‘

```jsx
class MinHeap {
  constructor() {
    this.heap = [];
  }

  getLength = () => {
    return this.heap.length;
  };

  push = (node) => {
    this.heap.push(node);
    let i = this.heap.length - 1;
    let parentI = Math.floor((i - 1) / 2);
    while (i > 0 && this.heap[parentI] > this.heap[i]) {
      this.swap(i, parentI);
      i = parentI;
      parentI = Math.floor((i - 1) / 2);
    }
  };

  pop = () => {
    if (this.heap.length === 1) {
      return this.heap.pop();
    }

    const result = this.heap[0];
    this.heap[0] = this.heap.pop();
    let i = 0;
    while (true) {
      const leftI = i * 2 + 1,
        rightI = i * 2 + 2;
      if (leftI >= this.heap.size) {
        break;
      }
      let nextI = i;
      if (this.heap[nextI] > this.heap[leftI]) {
        nextI = leftI;
      }
      if (rightI < this.heap.length && this.heap[nextI] > this.heap[rightI]) {
        nextI = rightI;
      }
      if (nextI === i) {
        break;
      }
      this.swap(i, nextI);
      i = nextI;
    }
    return result;
  };

  swap = (a, b) => {
    const temp = this.heap[a];
    this.heap[a] = this.heap[b];
    this.heap[b] = temp;
  };
}
const strToNumArr = (str) => str.split(" ").map(Number);

[testCase, ...arr] = require("fs")
  .readFileSync("dev/stdin")
  .toString()
  .trim()
  .split("\n");

[testNum, forNum] = testCase.split(" ").map(Number);
let topology = [];
let indegree = new Array(testNum + 1).fill(0);
const heapq = new MinHeap();
let result = [];

for (let i = 0; i <= testNum; i++) {
  topology.push([]);
}
arr.forEach((str) => {
  const [prev, next] = strToNumArr(str);
  topology[prev].push(next);
  indegree[next] += 1;
});

for (let i = 1; i <= testNum; i++) {
  if (indegree[i] == 0) {
    heapq.push(i);
  }
}

while (heapq.getLength()) {
  // console.log(heapq);
  data = heapq.pop();
  result.push(data);
  topology[data].forEach((v, i) => {
    indegree[v]--;
    if (!indegree[v]) {
      heapq.push(v);
    }
  });
}

console.log(result.join(" "));
```

## 01 íƒ€ì¼

```jsx
input = require("fs").readFileSync("/dev/stdin").toString().trim();
input = Number(input);

const DP = (num) => {
  let dpList = new Array(num + 1).fill(0).map((_, v) => v);
  dpList[1] = 1;
  dpList[2] = 2;

  for (let i = 3; i <= num; i++) {
    dpList[i] = (dpList[i - 1] + dpList[i - 2]) % 15746;
  }
  return dpList[num];
};
console.log(DP(input));
```

# ë§ˆì§€ë§‰ìœ¼ë¡œ

> ì•Œê³ ë¦¬ì¦˜ì„ ì–¼ë¥¸ ëë‚´ê³ , ì½”ë”© í…ŒìŠ¤íŠ¸ ì¤€ë¹„ë¥¼ í•´ì•¼ê² ë‹¤
