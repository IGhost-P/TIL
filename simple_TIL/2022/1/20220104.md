# TIL 간단회고

> 리액트 네이티브 안드로이드는 새로 깔거나, 나중에 하던지 해야겠다, 환경 설정 하느라 시간을 너무 많이 잡아 먹는다,
> 알고리즘은 동적 계획법 + 풀이를 했는데, 생각보다 좋은 알고리즘 방식이였다, 패턴화된 문제를 풀떄는 동적 계획법을 이용해서 풀어야 할 것 같다,
> 오늘 카카오 현장 실습은 다들 아이디어 회의를 하고, 서로 첨언 하는식으로 의견을 점차 넣어가는게 좋았다, 다들 삭막한 남자들 밖에 없어서 걱정했지만 다행이다,
> 제대로 가자 JS 스터디 준비를 하면서, 내가 당연하게 알고있던 사실이 사실 잘 못 알고 있었던 정보가 있었다(화살표 함수에서 this..) JS는 이번 겨울 Jonas를 들으면서 개념 + 실습을 확실하게 다져놔야 할 것 같다..,
> 피그마는 역시 같이 해보면서 배우니깐 빠른것 같다, 하지만 한시간만에 끝내고 갈라니 하다만 느낌이 나서, 하루는 토익 2시간, 하루는 피그마 2시간으로 시간을 분배해서 해야할것 같다!
> 토익 같은 경우는 안그래도 영어를 잘 모르는데 혼자 할라니 너무 힘들었다. RC강의를 들으면서 문제를 많이 풀어보자

# Today I Learned

- [x] TIL에서 퀴즈 형식으로 마무리하기
- [x] 타임로그 작성
- [x] 리엑트 네이티브 (09:15~11:15, 12:00~12:30)
- [x] 알고리즘 (1:13~3:55)
- [x] 헐크(12:30~1:13, 4:00~4:55)
- [x] 제대로 가자 스터디 준비
- [x] 피그마
- [x] 토익

---

# 리액트 네이티브

오늘 배운건 사실 환경 설정 밖에 없다

## 1. 애뮬레이터 실행시 ~ AVD 에러

> AVD CPU가 아니라 생기는 문제, 이때는 애뮬레이터를 설치 할떄, arm64-v8a를 지원하는 imgaes로 설치해야함

## 2. 해당 장치를 killed 해라?

> 아직 해결 하지 못한 에러이긴 한데, 환경변수 문제라고 한다, 하지만 열심히 설정을 바꾸어 보았지만 달라지는건 없었다 ㅎㅎ, 내일 모레 찾아온 사이트를 바탕으로 바꿔봐야겠다

# 알고리즘

## 동적 계획법

> 동적 계획법이란, 상향식 접근법으로, 작업을 작은 단위로 나누어 해결한 해답을 이용해(부분 문제는 중복된다) 상위 작업을 해결하는 방법이다, 대표적으로 Memoization이 있다.

## 동적 계획법 문제 : 11726 - 2\*n 스타일링

### 문제풀이

- 문제 해석에 애를 좀 먹었는데, 결론적으로 가로든 세로든 2의 크기는 정해졌있고, n의 크기에 따라 들어갈수있는 상자가 달라진다
- f(1) => 1 ,f(2) =>2, f(3) =>3 으로 피보나치수열 처럼 풀수있었따
- 동적 메모리로 풀어보고 싶었지만, 인덱스 접근에 문제가 생겨 임시방편으로 if문으로 에러를 처리 했다 => 별로 보기 좋은 코드가 아님

```python
    input_num = int(input())
    input_list = [0 for num in range(input_num)]
    input_list[0] = 1
    if(input_num > 1):
        input_list[1] = 2
    if(input_num > 2):
        input_list[2] = 3
    if (input_num > 2):
        for idx in range(2, len(input_list)):
            input_list[idx] = input_list[idx - 1] + input_list[idx - 2]
    result = int(input_list[input_num - 1]) % 10007
    print(result)
```

> 메모리 할당은 생각보다 시간이 많이 드는게 아니다, 괜히 동적으로 했다가 시간 잡아 먹지 말자

## 동적 계획법 문제 : 9461 - 파도난 수열

### 문제풀이

- 나선 수열이고, 리스트를 길게 보면, 삼각형 세변을 지나고 나서 다른 변을 합쳐가며 만들어진다는 것을 알 수 있다
- 즉 [1,1,1,2,2,3,4,5] 에서, 5까지는 1짜리 삼각형의 변과 더해지다가 그 이후는 6+2, 9+2, 11+3 형식인것을 알 수 있다

```python
    input_T = int(input())
    i = 0
    while i < input_T:
        input_N = int(input())
        N_list = [1, 1, 1, 2, 2, 3, 4, 5]
        for idx in range(8, 100):
            N_list.append(N_list[idx-1] + N_list[idx-5])
        i += 1
        print(N_list[input_N-1])
```

> 이전 문제와 달리 바로 밑에 인덱스가 아니긴했지만 결론적으로 하위 문제의 해답으로 상위 문제를 풀 수 있었다

## 동적 계획법 문제 : 1904 - 01 타일

### 문제풀이

- 가장 헷갈렸던 문제이다
- 점화식을 찾고 나면 쉽게 풀렸는데
- 즉, 00 타일과 1 타일을 붙이는데 별 다른 제약 조건이 없다, dp[n]은 dp[n-2]에 00 타일을 붙히고 dp[n-1]에 1 타일을 붙힐수 있다 = 붙히면 해당 가지수임 가지수가 추가되는게 아니라.
- 결론적으로 f(2) 에서 f(3) 으로 갈때 f(1) + f(2) 가 된다는것을 확인 할 수있다

```python
    import sys
    input_N = int(sys.stdin.readline())
    f_list = [0] * 1000001
    f_list[1] = 1
    f_list[2] = 2
    for idx in range(3, input_N+1):
        f_list[idx] = (f_list[idx-1] + f_list[idx-2]) % 15746
    print(f_list[input_N])
```

> 출력하는 값이 %로 나누는거였는데, 리스트를 만들고 나서 나누면 메모리가 너무 커지기 때문에 리스트에 넣을때 메모리에 나누면서 넣었다

---

# 마무리

> 많이 풀어보고 경험해보자, 깨부
