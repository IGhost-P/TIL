# TIL ê°„ë‹¨íšŒê³ 

- ìš°ì„ ìˆœìœ„íì™€ readlineë°©ì‹ì„ ì˜ íŒŒì•…í•´ì„œ ì‚¬ìš©í•˜ì
- ì§‘ì¤‘ë„ë¥¼ ì¢€ë„ ì˜¬ë¦¬ì

# Today I Learned

- [x] ë°±ì¤€ ì•Œê³ ë¦¬ì¦˜
- [x] jest

---

# ğŸ“¹ ë™ì˜ìƒ

[![section13](../../img/ì¸ë„¤ì¼/TIL.png)](https://youtu.be/RBp3ntN-qn8)

# 1202 : ë³´ì„ë„ë‘‘

## ë¬¸ì œí’€ì´

1. ê·¸ë¦¬ë””ë¡œ í’€ë©´ ë„ˆë¬´ í° ë°°ì—´ì„ 2ë²ˆ ìˆœíšŒí•´ì•¼í•˜ë¯€ë¡œ ì•½ n2~nlogn ì •ë„ ì‹œê°„ë³µì¡ë„ê°€ ìƒê¸´ë‹¤
2. maxHeapì„ ì´ìš© â‡’ ê°€ë°©ì„ ê¸°ì¤€ìœ¼ë¡œ ë³´ì„ì„ ë„£ì„ìˆ˜ ìˆìœ¼ë©´ ë„£ì–´ì£¼ê³ , ê·¸ì¤‘ ê°€ëŠ¥í•œ ê°€ë°©ì„ maxHeapì— ë„£ì–´ì£¼ë©´ maxHeapì˜ ìµœëŒ€ê°’ = í•´ë‹¹ ê°€ë°©ìœ¼ë¡œ ê°€ì§ˆìˆ˜ìˆëŠ” ìµœëŒ€ ê°€ì¹˜
3. ëª¨ë“  ê°€ë°©ì„ ë°˜ë³µí•´ì£¼ë©´ì„œ answerì— ë„£ìœ¼ë©´ ëœë‹¤

### ì²«ë²ˆì§¸ í’€ì´

```jsx
[NK, ...testCase] = require("fs")
  .readFileSync(process.platform === "linux" ? "/dev/stdin" : "./input.txt")
  .toString()
  .trim()
  .split("\n");

const [N, K] = NK.split(" ").map((e) => +String(BigInt(e)));

const jewel = testCase
  .slice(0, N)
  .map((e) => e.split(" ").map((e) => +String(BigInt(e))))
  .sort((a, b) => a[0] - b[0]);

const bag = testCase
  .slice(N)
  .map((e) => [+String(BigInt(e)), 0])
  .sort((a, b) => a[0] - b[0]);

const pq = [];
let answer = 0;
let idx = 0;
for (let i = 0; i < K; i++) {
  while (idx < N && jewel[idx][0] <= bag[i][0]) {
    pq.push(String(BigInt(jewel[idx][1])));
    idx++;
  }

  pq.sort((a, b) => a - b);

  if (pq.length) {
    answer += +String(BigInt(pq.pop()));
  }
}

console.log(String(BigInt(answer)));
```

ì•„ë¬´ë˜ë„ 10000000ê¸¸ì´ë¥¼ sortí•˜ë‹¤ë³´ë‹ˆ ë©”ëª¨ë¦¬ ì´ˆê³¼ ë¬¸ì œê°€ ìƒê¸°ëŠ”ê²ƒ ê°™ë‹¤, maxHeap ìë£Œ êµ¬ì¡°ë¥¼ êµ¬í˜„í•´ì„œ ì‚¬ìš©í•˜ì

```jsx
class MaxHeap {
  constructor() {
    this.heap = [];
  }
  swap(a, b) {
    // êµ¬ì¡°ë¶„í•´ í• ë‹¹ ë¬¸ë²•ìœ¼ë¡œ swap ê°€ëŠ¥
    [this.heap[a], this.heap[b]] = [this.heap[b], this.heap[a]];
  }
  size() {
    return this.heap.length;
  }
  push(value) {
    // ë§¨ë’¤ì— ì¶”ê°€ max heap ì´ë¯€ë¡œ ë¶€ëª¨ë‘ ë¹„êµí•´ì„œ í°ê°’ì„ ë¶€ëª¨ë‘ swap í•´ì¤˜ì•¼í•¨
    this.heap.push(value);
    let idx = this.heap.length - 1;
    let parent = Math.floor((idx - 1) / 2);

    while (this.heap[parent] < value) {
      this.swap(parent, idx);
      idx = parent;
      parent = Math.floor((idx - 1) / 2);
    }
    // return this.print()
  }
  // íì´ê¸° ë•Œë¬¸ì— ì‚­ì œëŠ” í•­ìƒ ë£¨íŠ¸ë…¸ë“œë¶€í„° ì´ë£¨ì–´ì§. ë£¨íŠ¸ ë…¸ë“œë¥¼ ì‚­ì œí•˜ê³ , ë§¨ë§ˆì§€ë§‰ ì¸ë±ìŠ¤ë¥¼ ë£¨íŠ¸ë‘ êµí™˜

  pop() {
    const lastIdx = this.heap.length - 1;
    let idx = 0;
    this.swap(0, lastIdx); // 0ë²ˆì´ ë£¨íŠ¸ë…¸ë“œ
    let value = this.heap.pop();

    while (idx < lastIdx) {
      let leftChildIdx = idx * 2 + 1;
      let rightChildIdx = idx * 2 + 2;

      // ì™¼ìª½ìì‹ ì¸ë±ìŠ¤ê°€ ë” í¬ë‹¤ëŠ” ëœ»ì€ ìì‹ë…¸ë“œê°€ ì—†ë‹¤ëŠ” ëœ»
      if (leftChildIdx >= lastIdx) {
        break;
      } else if (rightChildIdx >= lastIdx) {
        // ì™¼ìª½ ìì‹ë§Œ ìˆëŠ”ê²½ìš° ìì‹ê³¼ ë¹„êµí•´ì„œ í¬ë©´ ìŠ¤ì™‘
        if (this.heap[idx] < this.heap[leftChildIdx]) {
          this.swap(idx, leftChildIdx);
          idx = leftChildIdx;
        } else {
          break;
        }
      } else {
        // ë‘˜ë‹¤ ìˆëŠ”ê²½ìš° ì¤‘ ë‘ ìì‹ì´ ë£¨íŠ¸ë³´ë‹¤ ë‹¤ í°ê²½ìš°
        if (
          this.heap[leftChildIdx] > this.heap[idx] &&
          this.heap[rightChildIdx] > this.heap[idx]
        ) {
          // í°ê°’ì´ë‘ ìŠ¤ì™‘
          if (this.heap[leftChildIdx] > this.heap[rightChildIdx]) {
            this.swap(idx, leftChildIdx);
            idx = leftChildIdx;
          } else {
            this.swap(idx, rightChildIdx);
            idx = rightChildIdx;
          }
        } else if (this.heap[leftChildIdx] > this.heap[idx]) {
          // ì™¼ìª½ ìì‹ë§Œ ë£¨íŠ¸ë³´ë‹¤ í´ ê²½ìš°
          this.swap(leftChildIdx, idx);
          idx = leftChildIdx;
        } else if (this.heap[rightChildIdx] > this.heap[idx]) {
          // ì˜¤ë¥¸ìª½ ìì‹
          this.swap(rightChildIdx, idx);
          idx = rightChildIdx;
        } else {
          // ë‘˜ë‹¤ ì‘ì„ê²½ìš° ì•ˆë°”ê¿ˆ
          break;
        }
      }
    }
    return value;
  }

  print() {
    console.log(this.heap);
  }
}

const fs = require("fs");
const input = fs
  .readFileSync("dev/stdin")
  .toString()
  .trim()
  .split("\n")
  .map((v) => v.split(" ").map(Number));
const [N, K] = input.shift();
let jewel = input.splice(0, N).sort((a, b) => a[0] - b[0]);
let bag = input.map((v) => v[0]).sort((a, b) => a - b);
let answer = 0;
let possible = new MaxHeap();

let j = 0;
for (let i = 0; i < K; i++) {
  while (j < N && jewel[j][0] <= bag[i]) {
    possible.push(jewel[j][1]);
    j++;
  }

  if (possible.size()) {
    answer += possible.pop();
  }
}

console.log(answer);
```

# 2075 : Në²ˆì§¸ í°ìˆ˜

## ë¬¸ì œí’€ì´

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2fa68e77-efda-4a51-b3d2-a2f21b295ffe/Untitled.jpeg)

1. ë°°ì—´ì„ ëŒë©´ì„œ ìš°ì„ ìˆœìœ„í(max heap)ì—ë” ì§‘ì–´ë„£ìŒ
2. ì›í•˜ëŠ” në³´ë‹¤ íì˜ ê¸¸ì´ê°€ ê¸¸ì–´ì§„ë‹¤ë©´, ê°€ì¥ ì‘ì€ìˆ˜ë¥¼ ëº€ë‹¤
3. ì´ë ‡ê²Œí•˜ë‹¤ë³´ë©´ íëŠ” ê°€ì¥ í° ê°’ë¶€í„° në²ˆì§¸ í°ìˆ˜ê¹Œì§€ ìˆë‹¤

## ì²«í’€ì´

```jsx
[N, ...testCase] = require("fs")
  .readFileSync(process.platform === "linux" ? "/dev/stdin" : "./input.txt")
  .toString()
  .trim()
  .split("\n")
  .map((v) => v.split(" ").map(Number));

const queue = [];
for (let i = 0; i < N; i++) {
  for (let j = 0; j < N; j++) {
    queue.push(testCase[i][j]);

    if (queue.length > N) {
      queue.sort((a, b) => b - a);
      queue.pop();
    }
  }
}

console.log(queue.pop());
```

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/63a8df61-f26f-4c56-8d42-3afb02887f2b/Untitled.png)

ë¡œì§ìì²´ê°€ ë¬¸ì œê°€ ë˜ì§€ ì•Šì§€ë§Œ, sortí•˜ëŠ” ê³¼ì •ê³¼ ì…ë ¥ê°’ì„ ë°›ëŠ” ê³¼ì •ì—ì„œ ë©”ëª¨ë¦¬ ì´ˆê³¼ê°€ ë‚œë‹¤(ì…ë ¥ê°’ì´ ì»¤ì§€ë©´ fsë¡œ ë°›ì•„ì˜¬ìˆ˜ìˆëŠ” í•œê³„ê°€ ìˆëŠ”ë“¯ â‡’ readlineìœ¼ë¡œ í•´ê²°í•˜ì)

```jsx
const readline = require("readline");
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});

class Heap {
  constructor() {
    this.items = [];
  }
  swap(index1, index2) {
    let temp = this.items[index1];
    this.items[index1] = this.items[index2];
    this.items[index2] = temp;
  }
  parentIndex(index) {
    return Math.floor((index - 1) / 2);
  }
  leftChildIndex(index) {
    return index * 2 + 1;
  }
  rightChildIndex(index) {
    return index * 2 + 2;
  }
  parent(index) {
    return this.items[this.parentIndex(index)];
  }
  leftChild(index) {
    return this.items[this.leftChildIndex(index)];
  }
  rightChild(index) {
    return this.items[this.rightChildIndex(index)];
  }
  peek() {
    return this.items[0];
  }
  size() {
    return this.items.length;
  }
}
class MinHeap extends Heap {
  //bubbleUp
  bubbleUp() {
    let index = this.items.length - 1;
    while (
      this.parent(index) !== undefined &&
      this.parent(index) > this.items[index]
    ) {
      this.swap(index, this.parentIndex(index));
      index = this.parentIndex(index);
    }
  }
  //bubbleDown
  bubbleDown() {
    let index = 0;
    while (
      this.leftChild(index) !== undefined &&
      (this.leftChild(index) < this.items[index] ||
        this.rightChild(index) < this.items[index])
    ) {
      let smallerIndex = this.leftChildIndex(index);
      if (
        this.rightChild(index) !== undefined &&
        this.rightChild(index) < this.items[smallerIndex]
      ) {
        smallerIndex = this.rightChildIndex(index);
      }
      this.swap(index, smallerIndex);
      index = smallerIndex;
    }
  }
  //add
  add(item) {
    this.items[this.items.length] = item;
    this.bubbleUp();
  }
  //poll
  poll() {
    let item = this.items[0];
    this.items[0] = this.items[this.items.length - 1];
    this.items.pop();
    this.bubbleDown();
    return item;
  }
}

const queue = new MinHeap();
let n = 0;
let count = -1;

rl.on("line", function (line) {
  //  ì²« ì…ë ¥ê°’ì€ n
  if (count === -1) {
    count = parseInt(line);
    n = count;
    return;
  }

  // ì´í›„ ë‹¤ìŒ ì¤„ë¶€í„° nê°œì˜ ìˆ«ìê°€ ì…ë ¥ë¨ì„ ìŠ¤í˜ì´ìŠ¤ë°”ë¡œ ë„ì›€
  line.split(" ").forEach((v) => {
    queue.add(parseInt(v));

    if (queue.size() > n) {
      queue.poll();
    }
  });

  // në²ˆ ë°˜ë³µ í•˜ë‹¤ê°€ 0ì´ ë˜ë©´ ë
  count--;
  if (count === 0) rl.close();
}).on("close", function () {
  console.log(queue.peek());
  process.exit();
});
```

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/164f8ae4-6271-4495-a32b-a38e0e7949a4/Untitled.png)

# Jset

# ì½”ë“œ í€´ì¦ˆ 2

> Disabled Button Gray Code Quiz Spec

### Mockup

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8b666d75-8e1e-4871-b4f9-a7f29d12b1e6/Untitled.png)

### Spec

- use web color "gray"
- Test flows:
  - disable button â†’ button is gray â†’ enable button â†’ button is red
  - click button to change color â†’ disable btn â†’ btn is gray â†’ enable btn â†’ btn is blue

## í…ŒìŠ¤íŠ¸ ì½”ë“œ

### ë‚˜ì˜ ë‹µ

```jsx
import { render, screen, fireEvent } from "@testing-library/react";
import App from "./App";

test("test click btn color status", () => {
  render(<App />);

  const button = screen.getByRole("button", { name: "Change to blue" });

  expect(button).toHaveStyle({ backgroundColor: "red" });

  fireEvent.click(button);

  expect(button).toHaveStyle({ backgroundColor: "blue" });
  expect(button.textContent).toBe("Change to red");
});

test("checkbox click => button disable", () => {
  render(<App />);

  const checkbox = screen.getByRole("checkbox");
  const button = screen.getByRole("button");

  fireEvent.click(checkbox);
  expect(button).toBeDisabled();

  fireEvent.click(checkbox);
  expect.toBeEnabled();
});

test("checkbox name is disable button", () => {
  render(<App />);

  const checkbox = screen.getByRole("checkbox", { name: "Disable button" });

  expect(checkbox).not.toBeChecked();
});

test("chekcbox clicked -> button is gray", () => {
  render(<App />);

  const checkbox = screen.getByRole("checkbox", { name: "Disable button" });
  const button = screen.getByRole("button");

  fireEvent.click(checkbox);
  expect(button).toHaveStyle({ backgroundColor: "gray" });

  fireEvent.click(checkbox);
  expect(button).toHaveStyle({ backgroundColor: "red" });
});

test("After chaged button color to blue, checkbox clicked -> button is gray", () => {
  render(<App />);

  const button = screen.getByRole("button");
  const checkbox = screen.getByRole("checkbox", { name: "Disable button" });

  fireEvent.click(button);
  fireEvent.click(checkbox);

  expect(button).toHaveStyle({ backgroundColor: "gray" });

  fireEvent.click(checkbox);
  expect(button).toHaveStyle({ backgroundColor: "blue" });
});
ã„¹;
```

### ì„¼ì„¸ ë‹µ

```jsx
import { render, screen, fireEvent } from "@testing-library/react";
import App from "./App";
import { replaceCamelWithSpaces } from "./App";

test("button has correct initial color", () => {
  render(<App />);

  // find an element with a role of button and text of 'Change to blue'
  const colorButton = screen.getByRole("button", { name: "Change to blue" });

  // expect the background color to be red
  expect(colorButton).toHaveStyle({ backgroundColor: "red" });

  // click button
  fireEvent.click(colorButton);

  // expect the background color to be blue
  expect(colorButton).toHaveStyle({ backgroundColor: "blue" });

  // expect the button text to be 'Change to red'
  expect(colorButton.textContent).toBe("Change to red");
});

test("initial conditions", () => {
  render(<App />);

  // check that the button starts out enabled
  const colorButton = screen.getByRole("button", { name: "Change to blue" });
  expect(colorButton).toBeEnabled();

  // check that the checkbox starts out unchecked
  const checkbox = screen.getByRole("checkbox");
  expect(checkbox).not.toBeChecked();
});

test("Checkbox disables button on first click and enables on second click", () => {
  render(<App />);
  const checkbox = screen.getByRole("checkbox", { name: "Disable button" });
  const colorButton = screen.getByRole("button", { name: "Change to blue" });

  fireEvent.click(checkbox);
  expect(colorButton).toBeDisabled();

  fireEvent.click(checkbox);
  expect(colorButton).toBeEnabled();
});

test("Disabled button has gray background and reverts to red", () => {
  render(<App />);
  const checkbox = screen.getByRole("checkbox", { name: "Disable button" });
  const colorButton = screen.getByRole("button", { name: "Change to blue" });

  // disable button
  fireEvent.click(checkbox);
  expect(colorButton).toHaveStyle("background-color: gray");

  // re-enable button
  fireEvent.click(checkbox);
  expect(colorButton).toHaveStyle("background-color: red");
});

test("Clicked disabled button has gray background and reverts to blue", () => {
  render(<App />);
  const checkbox = screen.getByRole("checkbox", { name: "Disable button" });
  const colorButton = screen.getByRole("button", { name: "Change to blue" });

  // change button to blue
  fireEvent.click(colorButton);

  // disable button
  fireEvent.click(checkbox);
  expect(colorButton).toHaveStyle("background-color: gray");

  // re-enable button
  fireEvent.click(checkbox);
  expect(colorButton).toHaveStyle("background-color: blue");
});
```

## êµ¬í˜„ í™”ë©´

### ë¹¨ê°• â†’ íšŒìƒ‰ â†’ ë¹¨ê°•

### íŒŒë‘ â†’ íšŒìƒ‰ â†’ íŒŒë‘

---

# í•¨ìˆ˜ë¥¼ ìœ„í•œ ìœ ë‹› í…ŒìŠ¤íŒ…

<aside>
ğŸ’¡ **ë‹¨ìœ„ í…ŒìŠ¤íŠ¸**

- ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ëŠ” í”„ë¡œê·¸ë˜ë¨¸ì— ì˜í•´, í”„ë¡œê·¸ë˜ë¨¸ë¥¼ ìœ„í•´ ì‹œìŠ¤í…œ í”„ë¡œê·¸ë˜ë° ì–¸ì–´ë¡œ ë§Œë“  í…ŒìŠ¤íŠ¸ë‹¤.
- ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ëŠ” ì‹œìŠ¤í…œì˜ ìµœí•˜ìœ„ ê³„ì¸µì„ ëª…ì„¸í•˜ë ¤ëŠ” ì˜ë„ë¡œ ë§Œë“ ë‹¤.
- ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ì˜ ì»¤ë²„ë¦¬ì§€ëŠ” ìµœëŒ€í•œ 100%ì— ê°€ê¹Œì›Œì•¼ í•œë‹¤. ë³´í†µ ì»¤ë²„ë¦¬ì§€ì˜ ëª©í‘œëŠ” 90 ~ 99% ì‚¬ì´ê°€ ë˜ì–´ì•¼ í•œë‹¤.
</aside>

ë¦¬ì•¡íŠ¸ì—ì„œëŠ” ì¢…ì¢… ì»´í¬ë„ŒíŠ¸ì™€ ë¶„ë¦¬ë˜ì–´ìˆëŠ” í•¨ìˆ˜ê°€ ìˆë‹¤

- ì´ëŸ¬í•œ í•¨ìˆ˜ëŠ” ë‹¤ìˆ˜ì˜ ì»´í¬ë„ŒíŠ¸ê°€ ì¤‘ë³µí•´ì„œ ì‚¬ìš©í•˜ëŠ” í•¨ìˆ˜ì´ë‹¤
- ë˜ëŠ” ë³µì¡í•œ ë¡œì§ì´ê¸° ë•Œë¬¸ì— ì»´í¬ë„ŒíŠ¸ì—ì„œ ë¶„ë¦¬í•œ ê²½ìš°ì´ë‹¤

í•¨ìˆ˜ì˜ ìœ ë‹› í…ŒìŠ¤íŠ¸ëŠ”

- ë„ˆë¬´ ë³µì¡í•œ ë¡œì§ì´ê±°ë‚˜, ë„ˆë¬´ í° ë¡œì§ì¸ ê²½ìš°ì— ìœ ë‹› í…ŒìŠ¤íŠ¸ë¥¼ ê¶Œì¥í•œë‹¤
- ë˜ëŠ” ë„ˆë¬´ ë§ì€ ì—£ì§€ ì¼€ì´ìŠ¤ê°€ ìˆëŠ”ê²½ìš° ê¶Œì¥í•œë‹¤

<aside>
ğŸ’¡ **ì—£ì§€ì¼€ì´ìŠ¤**

ì—£ì§€ ì¼€ì´ìŠ¤ë€ ì•Œê³ ë¦¬ì¦˜ì´ ì²˜ë¦¬í•˜ëŠ” ë°ì´í„°ì˜ ê°’ì´ ì•Œê³ ë¦¬ì¦˜ì˜ íŠ¹ì„±ì— ë”°ë¥¸ ì¼ì •í•œ ë²”ìœ„ë¥¼ ë„˜ì„ ê²½ìš°ì— ë°œìƒí•˜ëŠ” ë¬¸ì œë¥¼ ê°€ë¦¬í‚¨ë‹¤.

ì˜ˆë¥¼ ë“¤ë©´ fixnumì´ë¼ëŠ” ë³€ìˆ˜ì˜ ê°’ì´ -128 ~ 127ì˜ ë²”ìœ„ë¥¼ ë„˜ëŠ” ìˆœê°„ ë¬¸ì œê°€ ë°œìƒí•˜ëŠ” ê²½ìš°ê°€ ìˆì„ ìˆ˜ ìˆë‹¤. ì–´ë–¤ ë¶„ëª¨ê°€ 0ì´ ë˜ëŠ” ìƒí™©ì²˜ëŸ¼ ë°ì´í„°ì˜ íŠ¹ì •ê°’ì— ëŒ€í•´ ë¬¸ì œê°€ ë°œìƒí•˜ëŠ” ê²½ìš°ë„ ë§ˆì°¬ê°€ì§€ë‹¤.

ì—£ì§€ ì¼€ì´ìŠ¤ëŠ” ì•Œê³ ë¦¬ì¦˜ì˜ íŠ¹ì„±ì— ë”°ë¼ ê°œë°œìê°€ ë©´ë°€íˆ ê²€í† í•˜ì—¬ ì˜ˆìƒí•  ìˆ˜ ìˆëŠ” ë¬¸ì œë‹¤. ì´ëŸ° ë¬¸ì œëŠ” ë””ë²„ê·¸ê°€ ì‰½ê¸°ë„ í•˜ê³  í…ŒìŠ¤íŠ¸ë¥¼ í†µí•´ ë¯¸ë¦¬ ë°©ì§€í•˜ê¸°ë„ ì‰½ë‹¤.

ë¹„ìŠ·í•œ ìƒí™©ì„ ê°€ë¦¬í‚¤ëŠ” ìš©ì–´ë¡œÂ **[ê²½ê³„ ì¼€ì´ìŠ¤(boundary case)](http://en.wikipedia.org/wiki/Boundary_case)**ê°€ ìˆë‹¤.

</aside>

### discribe ë¬¸ì¥

> í…ŒìŠ¤íŠ¸ë¥¼ ì¡°í•©í• ë•Œ ì‚¬ìš©í•œë‹¤

app.js

```jsx
import { useState } from "react";

export function replaceCamelWithSpaces(colorName) {
  return colorName.replace(/\B([A-Z])\B/g, " $1");
}
function App() {
  const [buttonColor, setButtonColor] = useState("red");
  const [disabled, setDisabled] = useState(false);

  const newButtonColor = buttonColor === "red" ? "blue" : "red";

  return (
    <div>
      <button
        style={{ backgroundColor: disabled ? "gray" : buttonColor }}
        onClick={() => setButtonColor(newButtonColor)}
        disabled={disabled}
      >
        Change to {newButtonColor}
      </button>
      <br />
      <input
        type="checkbox"
        id="disable-button-checkbox"
        defaultChecked={disabled}
        aria-checked={disabled}
        onChange={(e) => setDisabled(e.target.checked)}
      />
      <label htmlFor="disable-button-checkbox">Disable button</label>
    </div>
  );
}

export default App;
```

```jsx
import { render, screen, fireEvent } from "@testing-library/react";
import { replaceCamelWithSpaces } from "./App";
import App from "./App";

test("test click btn color status", () => {
  render(<App />);

  const button = screen.getByRole("button", { name: "Change to blue" });

  expect(button).toHaveStyle({ backgroundColor: "red" });

  fireEvent.click(button);

  expect(button).toHaveStyle({ backgroundColor: "blue" });
  expect(button.textContent).toBe("Change to red");
});

test("checkbox click => button disable", () => {
  render(<App />);

  const checkbox = screen.getByRole("checkbox");
  const button = screen.getByRole("button");

  fireEvent.click(checkbox);
  expect(button).toBeDisabled();

  fireEvent.click(checkbox);
  expect.toBeEnabled();
});

test("checkbox name is disable button", () => {
  render(<App />);

  const checkbox = screen.getByRole("checkbox", { name: "Disable button" });

  expect(checkbox).not.toBeChecked();
});

test("chekcbox clicked -> button is gray", () => {
  render(<App />);

  const checkbox = screen.getByRole("checkbox", { name: "Disable button" });
  const button = screen.getByRole("button");

  fireEvent.click(checkbox);
  expect(button).toHaveStyle({ backgroundColor: "gray" });

  fireEvent.click(checkbox);
  expect(button).toHaveStyle({ backgroundColor: "red" });
});

test("After chaged button color to blue, checkbox clicked -> button is gray", () => {
  render(<App />);

  const button = screen.getByRole("button");
  const checkbox = screen.getByRole("checkbox", { name: "Disable button" });

  fireEvent.click(button);
  fireEvent.click(checkbox);

  expect(button).toHaveStyle({ backgroundColor: "gray" });

  fireEvent.click(checkbox);
  expect(button).toHaveStyle({ backgroundColor: "blue" });
});

describe("spaces before camel-case capital letters", () => {
  test("Works for no inner capital letters", () => {
    expect(replaceCamelWithSpaces("Red")).toBe("Red");
  });
  test("Works for one inner capital letter", () => {
    expect(replaceCamelWithSpaces("MidnightBlue")).toBe("Midnight Blue");
  });
  test("Works for multiple inner capital letters", () => {
    expect(replaceCamelWithSpaces("MediumVioletRed")).toBe("Medium Violet Red");
  });
});
```

í•¨ìˆ˜ì˜ ë¦¬í„´ê°’ì„ toBeë¡œ ë°›ì•„ ì˜ˆìƒ í•  ìˆ˜ ìˆë‹¤

---

# í€´ì¦ˆ 3

> Color with spaces

### Spec

- Color starts with MediumVioletRed and changes to MidnightBlue
- Need to update existing tests since behavior changed
- Tests for checkbox disabling should still pass

```jsx
import { render, screen, fireEvent } from "@testing-library/react";
import { replaceCamelWithSpaces } from "./App";
import App from "./App";

test("test click btn color status", () => {
  render(<App />);

  const button = screen.getByRole("button", {
    name: "Change to Midnight Blue",
  });

  expect(button).toHaveStyle({ backgroundColor: "Medium VioletRed" });

  fireEvent.click(button);

  expect(button).toHaveStyle({ backgroundColor: "Midnight Blue" });
  expect(button.textContent).toBe("Change to Medium Violet Red");
});

test("checkbox click => button disable", () => {
  render(<App />);

  const checkbox = screen.getByRole("checkbox");
  const button = screen.getByRole("button");

  fireEvent.click(checkbox);
  expect(button).toBeDisabled();

  fireEvent.click(checkbox);
  expect.toBeEnabled();
});

test("checkbox name is disable button", () => {
  render(<App />);

  const checkbox = screen.getByRole("checkbox", { name: "Disable button" });

  expect(checkbox).not.toBeChecked();
});

test("chekcbox clicked -> button is gray", () => {
  render(<App />);

  const checkbox = screen.getByRole("checkbox", { name: "Disable button" });
  const button = screen.getByRole("button");

  fireEvent.click(checkbox);
  expect(button).toHaveStyle({ backgroundColor: "gray" });

  fireEvent.click(checkbox);
  expect(button).toHaveStyle({ backgroundColor: "Midium VioletRed" });
});

test("After chaged button color to Midnight Blue, checkbox clicked -> button is gray", () => {
  render(<App />);

  const button = screen.getByRole("button");
  const checkbox = screen.getByRole("checkbox", { name: "Disable button" });

  fireEvent.click(button);
  fireEvent.click(checkbox);

  expect(button).toHaveStyle({ backgroundColor: "gray" });

  fireEvent.click(checkbox);
  expect(button).toHaveStyle({ backgroundColor: "Midnight Blue" });
});

describe("spaces before camel-case capital letters", () => {
  test("Works for no inner capital letters", () => {
    expect(replaceCamelWithSpaces("Red")).toBe("Red");
  });
  test("Works for one inner capital letter", () => {
    expect(replaceCamelWithSpaces("MidnightBlue")).toBe("Midnight Blue");
  });
  test("Works for multiple inner capital letters", () => {
    expect(replaceCamelWithSpaces("MediumVioletRed")).toBe("Medium Violet Red");
  });
});
```

[]()

## êµ¬í˜„ í™”ë©´

---

# ìœ ë‹›í…ŒìŠ¤íŠ¸ë¥¼ í•˜ëŠ” ê²½ìš°

1. ì•ì„œë§í•œ ë³µì¡í•œ ê²½ìš°ì™€ ë¶„ë¦¬ëœê²½ìš°
2. ê¸°ëŠ¥ í…ŒìŠ¤íŠ¸ì˜ ì‹¤íŒ¨ ì›ì¸ì„ íŒë‹¨í•˜ë ¤ëŠ” ê²½ìš°
   1. ì‹¤íŒ¨ ì €í•­ë ¥ì´ ì¢‹ë‹¤ì§„ë‹¤ â‡’ í…ŒìŠ¤íŠ¸ì˜ ë³µì›ë ¥ì´ ì¢‹ì•„ì§
   2. í•˜ì§€ë§Œ ë†’ì€ ìˆ˜ì¤€ì˜ ì½”ë“œë¼ë©´ ì›ì¸ì´ ê´‘ë²”ìœ„í•´ì§„ë‹¤

---

# ë§ˆì§€ë§‰ìœ¼ë¡œ

> ì·¨ì—… ê²°ì •ì€ ë‚œê±° ê°™ìœ¼ë‹ˆ ë§ˆë¬´ë¦¬ë§Œ ì˜í•˜ì!
