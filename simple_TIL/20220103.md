# TIL 간단회고
> 22년 취업의 해가 밝았다. 이번 겨울 방학에는 네이버 핵데이와, 우태캠을 위해 공부하자

# Today I Learned
- [x] 바닐라 JS (JS런타임, 실행 컨텍스트)
- [x] 패캠 올인원 알고리즘 - 재귀 용법
- [x] 프로그래머스 정렬 알고리즘 풀이 - 가장 큰수, H-index
- [x] 피그마 - 연정's 피그마
- [x] 카카오 현장 실습 - 헐크팀
---
# 바닐라 JS
## JS 런타임
우선 JS를 어떻게 설명하는지 얘기해 보자면
> JS는 고급 언어이며, 가비지 콜렉터로 메모리 관리를 하고 JIT 런타임을 하고 프로토타입으로 객체를 다루고 일급 합수와 동적이며 멀티 프로그래밍을 지원하며, 단일 스레드이면서 이벤트 루프 동시성 모델이다.
자 그럼 여기서 JS 엔진을 살펴보자면?
![JS엔진](https://www.notion.so/section-8-How-JavaScript-Works-Behind-the-Scense-3df1734d3d4d477087cd7fd70642d918#dbbb3ff8d53e4b30bb2bd6e8e56ef95b)
- 호출 스택
- 힙
으로 구성되어있다
이는 JIT 런타임(실행 시점에 컴파일을 하고 실행을 함)을 통해 실행이 될떄 호출 스택에 올라가며, 동적인 메모리는 힙으로 구성된다
### 그래서 JS 런타임이 뭔데?
![JS런타임](https://www.notion.so/section-8-How-JavaScript-Works-Behind-the-Scense-3df1734d3d4d477087cd7fd70642d918#dbbb3ff8d53e4b30bb2bd6e8e56ef95b)
- JS 엔진
- WEP API
- 콜백 큐
로 이루어져 있는 런타임을 말한다.
## 실행 컨텍스트
> JS코드의 환경요소가 저장되어있는 저장소
- 가변 환경
- 스코프 체인
- this 키워드로 구성되어있다
여기서 좀 알아볼것은 화살표 함수는 특수 인수와 this 키워드를 지원하지 않아, 원래 this는 가장 가까운 정규 함수를 찾아 가는데, 화살표 함수에서 this는 자신을 호출한 this로 간다(스코프 체인으로, this가 화살표 함수에 없으니 호출한 함수를 찾아가는것)

# 패캠 올인원 알고리즘 - 재귀용법
## 재귀 용법
> 재귀 호출을 통해 알고리즘을 구현하는것
즉, 함수 안에서 동일한 함수를 호출하는 형태이다
패턴으로는 2가지 형태가 있다 => 결과적으로 호출이 종료되는 값으로 수렴하는 식
```python
# 일반적인 형태1
def function(입력):
    if 입력 > 일정값: # 입력이 일정 값 이상이면
        return function(입력 - 1) # 입력보다 작은 값
    else:
        return 일정값, 입력값, 또는 특정값 # 재귀 호출 종료

즉, 일정 감소하거나, 증가하거나 여튼 재귀 호출 종료 쪽으로 수렴 된다.

# 일반적인 형태2
def function(입력):
    if 입력 <= 일정값:              # 입력이 일정 값보다 작으면
        return 일정값, 입력값, 또는 특정값              # 재귀 호출 종료
    function(입력보다 작은 값)
    return 결과값
```
# 프로그래머스 정렬 풀이 - 가장 큰수 , H-index
## 가장 큰수
### 문제 풀이
- 모든 가지수를 만들고 그중 가장 큰값을 찾는데 => 단순 문자열 비교나 숫자 비교로 해도 될듯?
- 근데 가중치로 생각하자면, n의 자리수가 가장 높을수록 큰값 즉 ,length가 낮으면서, 숫자가 큰게 앞으로 와야 숫자가 크다, 같을 경우 length가 길고, 숫자가 더 큰게 높은데.. 이렇게 경우의 수를 생각하면 효율성에서 문제가 생길듯
- 모든 가지수를 만드는 정렬 => 아니면 순열을 만드는 permutations함수를 이용..?
```python
import itertools
def solution(numbers):
    answer = ''
    # 모든 가지수를 만들고 그중 가장 큰값을 찾는데 => 단순 문자열 비교나 숫자 비교로 해도 될듯?
    # 근데 가중치로 생각하자면, n의 자리수가 가장 높을수록 큰값 즉 ,length가 낮으면서, 숫자가 큰게 앞으로 와야 숫자가 크다, 같을 경우 length가 길고, 숫자가 더 큰게 높은데.. 이렇게 경우의 수를 생각하면 효율성에서 문제가 생길듯
    numbers = list(map(str, numbers)) 
    numbers.sort(key = lambda x : x*3, reverse = True) # 원소가 1000 이하이기때문에, 자리를 맞춰놓고 비교한다는것. => 이 부분이 어려웠따
    return str(int(''.join(numbers)))
```
>람다 표현식에 익숙해져야 할것 같다 어렵다

## H-index
### 문제 풀이
- 정렬이랑 무슨 상관인지 몰랐다
- 그니깐 배열의 길이 -1 이 논문의 개수, 그중 논문이 인용된 횟수에, 몇번 인용되었는지,를 잘 찾아야한다는것
- 예시의 [3, 0, 6, 1, 5] 는 최대점부터 생각해보자면, 4번 인용, 하지만 4번 이상 인용된 논문은 2회 = 탈락, 3번 인용, 3번 이상 인용된 논문 3회이상 = 합격
- 이런식으로 최대 인용횟수 = 해당 인용횟수보다 크거나 같은 경우가 같아야 h-index라 하는것 같다
- 그렇다면 최대 인용에서 -1씩 해가면서 인용횟수가 이상인 경우를 찾으면 된다
```python
def solution(citations):
    answer = 0
    length_cita = len(citations)
    cited = 0
    cited_cita = 0
    i = 0
    while True:
        for citation in citations:
            if citation != 0:
                cited += 1
        for citation in citations:
            if citation >= cited:
                cited_cita += 1
        print("인용",cited)
        print("인용 논문",cited_cita)
        if cited_cita >= cited:
            return cited
        else:
            i += 1
            cited = 0
            cited_cita = 0
            cited -= i
    return answer

    # 다른 사람
    def solution(citations):
    citations.sort(reverse=True)
    for idx , citation in enumerate(citations): # 인덱스를 뽑기 위해 이렇게 사용한것 같다. 좋은 코드다
        if idx >= citation:
            return idx
    return len(citations)
```
> 점차 내려가는 식으로 풀었는데 생각해보니, 점차 내려가는건 내림차순으로 해놓고, 인덱스만 늘려가면 똑같은 방법이였다. 코드 낭비가 되지 않게 조심하자

# 피그마 - 연정's 피그마
> 정리로 할거는 없었지만, 오늘 보고 넘어가지 말고, 실습 형태로 배워가는게 좋을것 같다, 내일 부터는 1번은 보고 바로 해보고 2번은째는 막히는 부분을 동영상을 따라가며 배우는 형태로 해보고 싶다.

# 카카오톡 현장 실습 - 팀 헐크
> PM을 맡게 되었다 기간은 짧은데 좋은 폼을 보여줘야한다는 부담감이 살짝 있다. 열심히 해서 공모전까지 입상해 돈 벌고 싶다

# 마무리
> 이번해는 작년보다 진짜 더 죽어라해야한다. 죽었다 생각하고 공부하고 공부하자. 딱 지금 1년만 더 하면 취업 할 수 있을것 같다, 화이팅! 🔥