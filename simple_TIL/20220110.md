# TIL 간단회고

> JS는 챕터 9-1부 정도 진행 했는데, 코딩 테스트까지 무난했다, 이번달 20일 정도가 남았는데, 20일만에 남츤 챕터가 8개 정도 있는데 1주일에 적어도 2챕터씩은 나가야 할것같다, 이번주에는 섹션 11 중간까지는 끝내고 싶다.
> 알고리즘은 오늘 프로그래머스 level 4 정도 문제를 풀었는데 로직조차 너무 힘들었다, 이해하고나면 쉽지만 이해하는게 쉽지 않다,, 더 많은 문제를 접해봐야할것 같다
> 피그마는 이제 어느정도 디자인을 들어가도 될정도가 된것같다, auto layout에 대해서 배웠다

# Today I Learned

- [x] VanillaJS (09:25~12:25)
- [x] 알고리즘 (1:08 ~ 3:59)
- [x] VanillaJS - s (7:03~8:01)
- [x] 피그마 (9: 14 ~ 11:30)

- ***

# VanillJS

## 객체 구조 분해 할당

> 선언된 객체 구조를 분해해 키 값을 식별자에게 전달 할 수 있다.

```javascript
obj = {
    a : 1
    b : 3
}

const { a, b } = obj // 이름이 같아야한다.
```

- 이미 선언된 변수를 객체 구조할당에 사용하기 위해 전환하려면 {} 중괄호 안에서 객체 구조 할당을 하면 된다
- 중첩 객체는 선언을 할때 dept순으로 할당해주면된다
- 함수의 매개 변수 또한 구조 분해 할당이 가능하다

## 스프레드 연산자

> '...' 을 통해 배열 구조 분해를 할 수 있다

```javascript
const arr = [1, 2, 3];
const newArr = [...arr, 4, 5];
```

- 배열의 확장에 용이하다
- 이터러블한 요소에만 가능하다, 원래는 객체또한 되지 않았지만, 이제는 가능하다
- prompt의 입력값을 실시간으로 받아 배열에 저장해도, 스프레드가 가능하다

## Rest 패턴

> 매개변수 마지막에 '...' 을 통해 앞선 매개변수들보다 더 많은 인자가 들어오는 경우, 추가로 들어오는 나머지를 배열로 압축시킨다

```javascript
const foo = (a, b, ...rest) => console.log(rest);
foo(1, 2, 3, 4, 5, 6, 7);
```

- 생긴것은 스프레드와 똑같으나 작동 방식이 반대
- 객체와 함수 둘다 사용가능하다

## 단축 평가

**OR인 경우**

- false || 값 = 오른쪽 값을 내보냄 => 하지만 0, null, undefined또한 false로 평가되어 문제가 생김
- true || 값 = 왼쪽 값을 내보냄
- (왼쪽 값 || = 오른쪽값) = 왼쪽값이 fasle이면 왼쪽 값이 오른쪽 값으로 평가됨
  **Nullish인 경우**

- false ?? 값 = 오른쪽 값을 내보냄 => 하지만 0, null, undefined또한 true
- true ?? 값 = 왼쪽 값을 내보냄
- (왼쪽 값 || = 오른쪽값) = 왼쪽값이 fasle이면 왼쪽 값이 오른쪽 값으로 평가됨

**AND인 경우**

- false || 값 = 왼쪽 값을 내보냄
- true || 값 = 오른쪽 값을 내보냄
- (왼쪽 값 || = 오른쪽값) = 왼쪽값이 true이면 왼쪽 값이 오른쪽 값으로 평가됨

## For .. fo 반복문

> 배열 반복을 쉽게 해준다

```javascript
const arr = [a, b, c, d, e];

for (const item of arr) console.log(itme); // if 문과 마찬가지로 하나의 문이면 {} 필요가 없다
```

- entrise() 메서드로 인덱스 + 요소를 뽑을 수 있다.

## 향상된 객체 리터럴

- 외부에 정의된 객체를 객체에 담을수 있음
- 객체 내부 함수 표현식이 쉬워짐
- 객체 내부에서 속성 계산이 가능해 졌다

# 알고리즘

## 그래프의 이해와 자료 구조

> 그래프란 노드와 간선으로 표현된 경로

### 그래프 종류

- 무방향 그래프 : 간선에 방향이 없음
- 방향 그래프 : 간선에 방향
- 가중치 그래프 or 네트워크 : 간성에 가중치
- 연결 그래프 비연결 그래프 : 모든 노드가 다른 노드와의 연결이 있음 (나머지는 반대)
- 사이클과 비순환 그래프 : 사이클은 그래프 전체의 출발 노드와 도착 노드가 같은것, 비순환 그래프는 이러한 사이클이 없는것
- 완전 그래프 : 모든 노드가 서로 다 연결되어있는것

### 그래프와 트리의 차이

> 트리는 그래프의 특별한 한 종류 정도

## 그래프 기본 탐색 알고리즘

- BFS : 넓이 우선 탐색, 형제 노드를 다 확인 한뒤에 다음 dept로 간다
- DFS : 깊이 우선 탐색, 한쪽 자식 노드를 다 확인한 후, 형제 노드로 다시 시작함

### 파이썬으로 그래프를 표현하는 방법

> 딕셔너리 자료 구조를 이용해, 노드는 key, 해당 노드와 연결되어있는 노드는 value로 저장하면됨

# 알고리즘 문제 풀이

## 프로그래머스 - 도둑질

### 문제 풀이

**도둑이 훔치는 방법을 생각해 보면..**

- 현재 집을 고민할때, 현재 가질 수 있는 돈의 최대치를 고민해봐야한다

1. 이전 집을 털어서 현재 집을 못 터는 경우 = 이전 집을 털었을때 가질 수 있는 돈의 최대치
2. 이전전 집을 털어서 현재 집을 털수 있는 경우 = 현재집 + 이전전집을 털었을때 가질수 있는 돈의 최대치
   이 둘중에서 최대치를 골라 , 어떤 선택이 더 좋은지 확인해야한다

**도둑의 시작점을 생각해보면**

1. 배열의 첫 시작집을 털면, 끝까지 못턴다 = 끝집이 첫집의 바로 옆집이기 때문
2. 배열의 첫 시작집을 털지 않으면, 끝까지 털수 있다

```python
def solution(money):
    answer = 0
    # 1번집을 턴다는 가정의 동적 계획법
    dp1: list = [0]*len(money)
    # 1번집을 털지 않는다는 가정의 동적 계획법
    dp2: list = [0]*len(money)

    # 1번 집부터 털었을때
    for idx in range(1, len(money)-1):
        dp1[0] = money[0]
        dp1[idx] = max(dp1[idx-1], money[idx] + dp1[idx-2])

    # 1번 집부터 털지 않았을때
    for idx in range(1, len(money)):
        dp2[0] = 0
        dp2[idx] = max(dp2[idx-1], money[idx] + dp2[idx-2])

    return max(dp1[-2], dp2[-1])
```

- 로직이 생각이 안나 힘들었다, 자주 풀어보면서 이러한 동적 계획법에 대해서 생각해야 겠다

## 프로그래머스 - 모의고사

### 문제 풀이

**나와 있는 값을 이용하면..**

- 수포자 1, 2, 3 패턴을 파악해 어차피 1~5까지의 번호 들을 나열하자
- 답을 알려주니, 해당 답과 수포자들의 배열을 돌면서 맞는지 틀린지 확인하자

```python
def solution(answers):
    answer = []

    fir_math_dropper = [1, 2, 3, 4, 5]
    fir = 0
    sec_math_dropper = [2, 1, 2, 3, 2, 4, 2, 5]
    sec = 0
    thr_math_dropper = [3, 3, 1, 1, 2, 2, 4, 4, 5, 5]
    thr = 0
    scored = list()
    for idx, answer in enumerate(answers):
        if (fir_math_dropper[idx%5] == answer):
            fir += 1
        if (sec_math_dropper[idx%8] == answer):
            sec += 1
        if (thr_math_dropper[idx%10] == answer):
            thr += 1
    scores = [fir,sec,thr]
    for idx, score in enumerate(scores):
        if (score == max(scores)):
            scored.append(idx+1)
    return scored
```

- 좀 어거지로 푼거 같았는데, 인터넷에 찾아봐도 이 로직이 맞았다.

# 피그마 : Button 만들기

- option + shift를 하고 드래그를 하면 요소가 복사되 드래그 된다,
- 추가로 command + D 하면 해당 방향으로 같은 거리 만큼 복사가도미
- 스타일을 지정 할때 '/' 를 이용하면 상위, 하위 구조로 나누어 로컬 환경에 저장된다
- 외부에 있는 스타일도 끌고 오고 수정도 가능하다
- autoLayout의 기능은 1. 레이아웃 안 요소가 복사되면 자동으로 프레임을 맞춰줌, 2. 요소간 간격도 변경 가능, 3. 프레임안 요소들의 정렬또한 정할수 있다
- autoLayout은 요소에 따라 크기가 달라지니 꼼수로 불투명도 100% 인 라인으로 크기를 유지 할 수 있다 (해당 라인이 가장 커야함)

- ***

# 마지막으로

> 카카오 현장 실습에 시간을 좀 투자 해야할것 같다, 생각보다 해야할게 많았다, 그리고 계절 학기 과제 까먹지 말자
